#!/usr/bin/python


from itertools import imap, islice, repeat
import json
import math
import numpy
from numpy import array
from optparse import OptionParser
import re
import sys
try:
    import xml.etree.cElementTree as ElementTree
except ImportError:
    import xml.etree.ElementTree as ElementTree

from pyproj import Proj, transform

from tesselate import Tesselator


tesselate = Tesselator(counterclockwise=True)


class VertexCache(list):

    def insert(self, vertex):
        self.append(vertex)
        return len(self) - 1


class Polygon(object):

    def __init__(self, vertices, normal=None):
        self.vertices = vertices
        if normal is None:
            normal = numpy.cross(vertices[0], vertices[1])
            self.normal = normal / math.sqrt(numpy.dot(normal, normal))
        else:
            self.normal = normal
        if len(vertices) == 3:
            self.faces = [(0, 1, 2)]
        else:
            vertex_map = dict((tuple(vertex), i) for i, vertex in enumerate(self.vertices))
            self.faces = list(tuple(vertex_map[vertex] for vertex in triangle) for triangle in tesselate((self.vertices,)))

    def normal(self):
        x = numpy.cross(self.vertices[0], self.vertices[1])
        return x / math.sqrt(numpy.dot(x, x))


def main(argv):
    parser = OptionParser()
    parser.add_option('-f', '--format', choices=['json', 'obj'], default='json')
    parser.add_option('-l', '--limit', metavar='LIMIT', type=int)
    parser.add_option('-o', '--center-on-origin', action='store_true')
    parser.add_option('-p', '--project', action='store_true')
    parser.add_option('-r', '--radius', default=6378137, metavar='RADIUS', type=float)
    parser.add_option('-z', '--zero-altitude', action='store_true')
    options, args = parser.parse_args(sys.argv[1:])
    files = imap(open, args) if args else (sys.stdin,)
    polygons = []
    for f in files:
        gml = ElementTree.parse(f)
        buildings = gml.findall('//{http://www.opengis.net/citygml/building/1.0}Building')
        if options.limit is not None:
            buildings = islice(buildings, options.limit)
        for building in buildings:
            measuredHeight = float(building.find('.//{http://www.opengis.net/citygml/building/1.0}measuredHeight').text)
            building_polygons = []
            for posList in building.findall('.//{http://www.opengis.net/gml}posList'):
                vertices = array(zip(*[imap(float, re.split(r'\s+', posList.text))] * 3))
                assert all(vertices[0] == vertices[-1]) # first and last vertex must be the same
                building_polygons.append(Polygon(vertices[:-1]))
            if options.zero_altitude:
                offset = array([0, 0, -min(polygon.vertices[:, 2].min() for polygon in building_polygons)])
                for polygon in building_polygons:
                    polygon.vertices += offset
            polygons.extend(building_polygons)
    if options.project:
        proj = Proj(init='epsg:21781')
        wgeproj = Proj('+proj=latlong +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs')
        for polygon in polygons:
            lons, lats = transform(proj, wgeproj, polygon.vertices[:, 0], polygon.vertices[:, 1], radians=True)
            rs = 1.0 + polygon.vertices[:, 2] / options.radius
            xs = rs * numpy.cos(lats) * numpy.cos(lons)
            ys = rs * numpy.cos(lats) * numpy.sin(lons)
            zs = rs * numpy.sin(lats)
            polygon.vertices = array([ys, zs, xs]).transpose()
            # if the polygon has multiple faces then it is a complex polygon tesselated into triangles
            # calculate the normal to the surface of the sphere at the mid-point of the original polygon
            if len(polygon.faces) > 1:
                mid_lat = (lats.min() + lats.max()) / 2.0
                mid_lon = (lons.min() + lons.max()) / 2.0
                polygon.normal = array([math.cos(mid_lat) * math.cos(mid_lon), math.cos(mid_lat) * math.sin(mid_lon), math.sin(mid_lat)])
    vertexPositions, vertexNormals, faces = [], [], []
    for polygon in polygons:
        n = len(vertexPositions)
        vertexPositions.extend(imap(tuple, polygon.vertices))
        vertexNormals.extend(repeat(tuple(polygon.normal), len(polygon.vertices)))
        faces.extend(tuple(i + n for i in face) for face in polygon.faces)
    if options.center_on_origin:
        # FIXME this should really be done earlier using numpy
        minimum = tuple(min(v[i] for v in vertexPositions) for i in xrange(3))
        maximum = tuple(max(v[i] for v in vertexPositions) for i in xrange(3))
        offset = tuple(-(minimum[i] + maximum[i]) / 2 for i in xrange(3))
        vertexPositions = list(tuple(v[i] + offset[i] for i in xrange(3)) for v in vertexPositions)
    if options.format == 'json':
        json.dump(dict(indices=list(i for face in faces for i in face), vertexNormals=list(component for vertexNormal in vertexNormals for component in vertexNormal), vertexPositions=list(component for vertexPosition in vertexPositions for component in vertexPosition)), sys.stdout, separators=(',', ':'))
    elif options.format == 'obj':
        for v in vertexPositions:
            print 'v %f %f %f' % v
        for vn in vertexNormals:
            print 'vn %f %f %f' % vn
        for face in faces:
            print 'f %s' % ' '.join(str(i + 1) for i in face)


if __name__ == '__main__':
    sys.exit(main(sys.argv))
